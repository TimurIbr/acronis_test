# acronis_test
This is a testing task from acronis http://dati.mipt.ru/postuplenie-na-kafedru-v-2020-godu/
9.       Golang -- бесконечные циклы в горутинах. Немного зверская) задача
В golang код исполняется в горутине (goroutine), -- легковесном аналоге потока, который полностью реализуется в userspace. Одна программа на Go может запускать много горутин, чтобы выполнять много задач параллельно.
 
До версии 1.14 golang использовал кооперативную многозадачность при планировании исполнения горутин. Это означает, что переключение между горутинами происходит только в точках, где они делают вызовы go runtime. Для горутин, которые занимаются в основном вводом-выводом, это не проблема, так как они часто зовут функции, чтобы прочесть или записать что-либо в сокет или файл.
 
Если же горутина занята вычислительной задачей, она может неопределённо долго не вызывать никакие функции из go runtime, из-за чего другие горутины не смогут выполняться.
 
Простое “решение” этой проблемы -- это регулярно звать функцию runtime.Gosched().
 
Ваша задача -- получить на вход исходный файл программы на Go и автоматически расставить вызовы runtime.Gosched() перед всеми обратными рёбрами в CFG (control flow graph).
 
Стандартная библиотека Go экспортирует значительную часть компилятора golang. Используйте пакеты go/parser, go/ast и go/format для построения AST, его изменения и сохранения AST назад в текст.
 
Оцениваться будет не только решение, но и стиль кода, его архитектура, а также то, как и насколько он протестирован.
 
Вопрос для обсуждения на собеседовании: чем плохо решение расставить runtime.Gosched() перед всеми обратными рёбрами?
